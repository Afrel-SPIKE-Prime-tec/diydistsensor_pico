# DIY Distance Sensor(LEGO SPIKE prime) Version 0.6
# for Raspberry Pi Pico
# by takuya matsubara

# Reference Data
# https://github.com/sonoisa/cheese/
# https://github.com/ahmedjouirou/legopup_arduino
# https://www.philohome.com/wedo2reverse/protocol.htm
import machine
import time

# RasPi Pico : SPIKE Hub
#  (6)GP4 ---> (6)Device to Hub
#  (7)GP5 <--- (5)Hub to Device
#  (8)GND ---- (3)GND
GPIOTX = 4   # GPIO pin:TX
GPIORX = 5   # GPIO pin:RX

# message header
# 0x00+(00～3F)System message
# 0x40+(00～3F)Command message
# 0x80+(00～3F)Info message
# 0xC0+(00～3F)Data message

keywords = [
  0x00,
  0x40,0x3E,0x81,
  0x49,0x07,0x07,0xB6,
  0x52,0x00,0xC2,0x01,0x00,0x6E,
  0x5F,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0xA0,
  0xA7,0x00,0x66,0x6C,0x6F,0x61,0x74,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x0E,
  0x9F,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEB,
  0x9F,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE8,
  0x9F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE9,
  0x87,0x04,0x00,0x7C,
  0x8F,0x05,0x10,0x00,0x65,
  0x97,0x80,0x04,0x03,0x02,0x01,0xEC,
  0xA6,0x00,0x69,0x6E,0x74,0x33,0x32,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x0D,
  0x9E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEA,
  0x9E,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE9,
  0x9E,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE8,
  0x86,0x04,0x00,0x7D,
  0x8E,0x05,0x10,0x00,0x64,
  0x96,0x80,0x04,0x02,0x03,0x00,0xEC,
  0xA5,0x00,0x69,0x6E,0x74,0x31,0x36,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x08,
  0x9D,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE9,
  0x9D,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEA,
  0x9D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEB,
  0x85,0x04,0x00,0x7E,
  0x8D,0x05,0x10,0x00,0x67,
  0x95,0x80,0x04,0x01,0x03,0x00,0xEC,
  0xA4,0x00,0x69,0x6E,0x74,0x38,0x5F,0x61,0x72,0x72,0x61,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x36,
  0x9C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xE8,
  0x9C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEB,
  0x9C,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEA,
  0x84,0x04,0x00,0x7F,
  0x8C,0x05,0x10,0x00,0x66,
  0x94,0x80,0x04,0x00,0x03,0x00,0xEC,
  0x9B,0x00,0x66,0x6C,0x6F,0x61,0x74,0x00,0x00,0x00,0x14,
  0x9B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEF,
  0x9B,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEC,
  0x9B,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xED,
  0x83,0x04,0x00,0x78,
  0x8B,0x05,0x10,0x00,0x61,
  0x93,0x80,0x01,0x03,0x02,0x01,0xED,
  0x9A,0x00,0x69,0x6E,0x74,0x33,0x32,0x00,0x00,0x00,0x17,
  0x9A,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEE,
  0x9A,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xED,
  0x9A,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEC,
  0x82,0x04,0x00,0x79,
  0x8A,0x05,0x10,0x00,0x60,
  0x92,0x80,0x01,0x02,0x03,0x00,0xED,
  0x99,0x00,0x69,0x6E,0x74,0x31,0x36,0x00,0x00,0x00,0x12,
  0x99,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xED,
  0x99,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEE,
  0x99,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEF,
  0x81,0x04,0x00,0x7A,
  0x89,0x05,0x10,0x00,0x63,
  0x91,0x80,0x01,0x01,0x03,0x00,0xED,
  0x90,0x00,0x69,0x6E,0x74,0x38,0x24,
  0x98,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEC,
  0x98,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEF,
  0x98,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x42,0xEE,
  0x80,0x04,0x00,0x7B,
  0x88,0x05,0x10,0x00,0x62,
  0x90,0x80,0x01,0x00,0x03,0x00,0xED,
  0x04
]

# 1000000/2400bps = 416.666micro sec
BAUD2400TIME = 416
BAUD2400TIMEH = int(BAUD2400TIME*3/2)

#--------------
def debug_message(str):
  led.value(1)
  print(str)
  led.value(0)
    
#--------------
# send 1Byte(Sensor to Hub)
def serial_senddata(dat):
  ch = (dat).to_bytes(1, "big")
  uart.write(ch)

#--------------
# recv 1Byte(Hub to Sensor)
def serial_recvdata():
  RECVTIMEOUT = 0x400000
  limit = 0

  while uart.any() == 0:
    limit += 1
    if limit > RECVTIMEOUT:
      return 0xffff

  dat = uart.read(1)
  return dat[0]

#--------------
# 2400bps send 1byte(Sensor to Hub)
def baud2400_senddata(dat):
  tx.value(0)
  time.sleep_us(BAUD2400TIME)  # start bit
  mask = 0x01
  while mask & 0xFF:
    if mask & dat:
      tx.value(1)
    else:
      tx.value(0)

    time.sleep_us(BAUD2400TIME) # data bit
    mask <<= 1

  tx.value(1)
  time.sleep_us(BAUD2400TIME)  # stop bit

#--------------
# 2400bps recv 1byte(Hub to Sensor)
def baud2400_recvdata():
  RECVTIMEOUT = 0x2000000
  # finding edge
  cnt = 0
  while rx.value() == 1:
    cnt += 1
    if cnt > RECVTIMEOUT:
      return 0xffff

  time.sleep_us(BAUD2400TIMEH) #wait 1.5bit
  mask = 0x01  # LSB
  dat = 0
  while mask & 0xFF:
    if rx.value() == 1:
      dat |= mask

    time.sleep_us(BAUD2400TIME)
    mask <<= 1 

  return dat

#--------------
def sensor_init():
  global sensor_error,sensor_value,sensor_connect
  sensor_error = 0
  sensor_value = 10   # dummy data
  sensor_connect = 0 # 

#--------------
def sensor_start():
  global led,tx,rx,uart  
  global sensor_error,sensor_connect
  led = machine.Pin(25, machine.Pin.OUT)
  tx = machine.Pin(GPIOTX, machine.Pin.OUT)
#  rx = machine.Pin(GPIORX, machine.Pin.IN, machine.Pin.PULL_UP)
  rx = machine.Pin(GPIORX, machine.Pin.IN)
  tx.value(1)

  debug_message("start")

  pulsecnt = 0
  while 1:
    dat = baud2400_recvdata()
    if dat == 0xF0 :  # exist Hub
      pulsecnt += 1
      if pulsecnt >= 40:
        break

  debug_message("detect")
  for i in range(30):
    time.sleep_us(BAUD2400TIME)

  baud2400_senddata(0xF0)
  tx.value(0)
  time.sleep_ms(500)
  tx.value(1)

  for code in keywords:
    baud2400_senddata(code)

  sensor_error = 0
  while 1:
    dat = baud2400_recvdata()
    if dat == 0x04:    # success
      sensor_connect = 1
      break

    if dat == 0xFFFF:  # timeout
      debug_message("timeout")
      break

    sensor_error += 1
    if sensor_error >= 40: # wrong data error
      debug_message("data error")
      break

  if sensor_connect == 0:  # error
    time.sleep_ms(100)
    return

  debug_message("connect")
  # success
#  uart = machine.UART(1)
  uart = machine.UART(1, baudrate=115200, tx=machine.Pin(GPIOTX), rx=machine.Pin(GPIORX))
  time.sleep_ms(5)

#--------------
def sensor_control():
  global sensor_error,sensor_value,sensor_connect
  if sensor_connect == 0:
    sensor_start()   # connection to hub
    return

  dat = serial_recvdata()
#  print(hex(dat))
  if dat == 0x02: # 
    sensor_value += 1
    if sensor_value > 9: sensor_value = 1
    sensor_error = 0
  elif dat == 0x43:
    dat = serial_recvdata()  # mode
    dat = serial_recvdata()  # get checksum
  elif dat == 0x46:
    dat = serial_recvdata()  # 0x00
    dat = serial_recvdata()  # 0xB9
    dat = serial_recvdata()  # size and mode
    mode = dat & 0b111
    recvcnt = 1 << ((dat >> 3)& 0b111)
    for i in range(recvcnt):
      dat = serial_recvdata()

    dat = serial_recvdata()  # get checksum
  elif dat == 0x4C:
    dat = serial_recvdata()  # value L
    dat = serial_recvdata()  # value H
    dat = serial_recvdata()  # get checksum
  else:
    dat = serial_recvdata()
    dat = serial_recvdata()

  if dat == 0xFFFF:  # timeout
    sensor_connect = 0
#    uart.deinit()   # not supported
    debug_message("exit")
    time.sleep(1)
    return

  chksum = 0xFF
  chksum ^= 0xC0
  chksum ^= sensor_value
  serial_senddata(0xC0) # header
  serial_senddata(sensor_value)
  serial_senddata(chksum)
  time.sleep_ms(5)

#--------------
sensor_init()

while 1:
  try:
    sensor_control()
  except KeyboardInterrupt:  # Ctrl+C
    break

debug_message("end")

